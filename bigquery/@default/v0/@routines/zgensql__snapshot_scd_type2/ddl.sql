create or replace table function `v0.zgensql__snapshot_scd_type2`(
  destination struct<
    project_id string
    , dataset_id string
    , table_id string
  >
  , snapshot_query string
  , exp_unique_key string
)
options(
  description="""Generate SQL for Snapshots in Slowly Changing Dimensions Type 2
"""
)
as

select
  -- DDL Query
  format("""
      # %s
      create table if not exists `%s`
      partition by DATE(valid_to)
      cluster by unique_key
      as %s
    """
    , header
    , destination_ref
    , snapshot_query
  ) as create_ddl
  , format("""
      # %s
      with source as (
        select
          *
          , ifnull(valid_to < (lead(valid_from) over (partition by unique_key order by valid_to nulls last)), false) as is_insane_valid_column
          , version_hash is null as is_insale_version_column
          , unique_key is null as is_insane_unique_key
        FROM %s
      )

      SELECT
        unique_key
        , if(countif(is_insane_valid_column) > 0, max(format('Contradict valid_from with previous valid_to at %%t, %%s', unique_key, version_hash)), null) as validate_record_lifetime
      from source
      group by unique_key
    """
    , header
    , destination_ref
  ) as validate_query
  , format("""
      # %s
      with grain as (
        SELECT
          date(valid_to) as changed_date, unique_key
          , approx_count_distinct(version_hash) as n_changed
        from %s
        group by changed_date, unique_key
      )
      , stats as (
        select change_date, approx_quantiles(n_changed, 4) from grain
      )
      select * from stats
    """
    , header
    , destination_ref
  ) as profile_query
  -- DML Query
  , format("""
      # %s
      merge `%s` T
      using
        (
          %s
        ) as S
      on
        T.valid_to is null
        and S.unique_key = T.unique_key
        and format('%%t', S.entity) = format('%%t', T.entity)
      -- Insert new records changed
      when not matched then
        insert row
      -- Deprecate old records changed
      when
        not matched by source
        and T.valid_to is null then
          update set
            valid_to = @timestamp
    """
    , header
    , destination_ref
    , snapshot_query
  ) as update_dml
  -- TVF DDL for Access
  , format("""
      # %s
      create or replace table function `%s`(_at timestamp)
      as
        select * from `%s`
      where
        -- when _at is null, use latest version
        (valid_from <= `_at` and ifnull(`_at` < valid_to, true))
        or
        (`_at` is null and valid_to is null)
    """
    , header
    , destination_ref
    , destination_ref
  ) as access_tvf_ddl
from unnest([struct(
  coalesce(
    format('%s.%s.%s', destination.project_id, destination.dataset_id, destination.table_id)
    , format('%s.%s', destination.dataset_id, destination.table_id)
    , error(format("Invalid Destination: %t", destination))
  ) as destination_ref
  , "Code generated by `v0.generate_sql__scd_type2`; DO NOT EDIT." as header
)])
left join unnest([struct(
  ifnull(
    format("""
      select
        %s as unique_key
        , version_hash
        , @timestamp as valid_from
        , timestamp(null) as valid_to
        , entity
      from
        (%s) as entity
        , (select as value generate_uuid()) as version_hash
      """
      , exp_unique_key
      , snapshot_query
    )
    , error(format("Invalid argument: %t", snapshot_query))
  ) as snapshot_query
)])
